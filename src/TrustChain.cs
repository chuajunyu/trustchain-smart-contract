using AElf.Sdk.CSharp;
using AElf.Types;
using Google.Protobuf.WellKnownTypes;
using System.Collections.Generic; // for List


namespace AElf.Contracts.TrustChain
{
    using System.Collections.Generic;
    // Contract class must inherit the class generated by the proto file
    public class TrustChain : TrustChainContainer.TrustChainBase
    {
        // adding this line is for preparing the contract deployment later,
        // to differentiate each person's contract.
        // This is because our testnet does not allow the deployment of two identical contracts.
        const string author = "test_1";

        public override Empty ProposeTransfer(TransferProposal input)
        {
            var transfer = new Transfer {
                Tokenid = input.Tokenid,
                To = input.To,
                From = input.From,
                Status = "pending"
            };

            State.Transfers[transfer.Tokenid] = transfer;
            
            var pendingProposals = State.Proposals[input.From] ?? new RepeatedString();
            pendingProposals.Values.Add(input.Tokenid);
            State.Proposals[input.From] = pendingProposals;

            var pendingApprovals = State.Approvals[input.To] ?? new RepeatedString();
            pendingApprovals.Values.Add(input.Tokenid);
            State.Approvals[input.To] = pendingApprovals;
            return new Empty();
        }

        public override Empty AcceptTransfer(TransferID input)
        {
            
            if (State.Transfers[input.Tokenid] == null) {
                return new Empty();
            }

            var transfer = State.Transfers[input.Tokenid];
            transfer.Status = "accepted";

            if (State.Proposals[transfer.From] == null) {
                return new Empty();
            }
            State.Proposals[transfer.From]?.Values.Remove(input.Tokenid);
            
            var approvedProposals = State.ApprovedProposals[transfer.From] ?? new RepeatedString();
            approvedProposals.Values.Add(input.Tokenid);
            State.ApprovedProposals[transfer.From] = approvedProposals;

            if (State.Approvals[transfer.To] == null) {
                return new Empty();
            }
            State.Approvals[transfer.To]?.Values.Remove(input.Tokenid);
            return new Empty();
        }

        public override RepeatedString GetPendingProposals(UserAddress input)
        {
            var pendingProposals = State.Proposals[input.Value] ?? new RepeatedString();
            
            return pendingProposals;
        }

        public override RepeatedString GetPendingAcceptances(UserAddress input)
        {
            var pendingApprovals = State.Approvals[input.Value] ?? new RepeatedString();

            return pendingApprovals;
        }

        public override Transfer GetTransfer(TransferID input)
        {
            return State.Transfers[input.Tokenid];
        }
    }
}
